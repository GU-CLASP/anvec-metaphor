<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Demo trainig :)</title>
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="//fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">

  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/skeleton.css">
  <style>
  textarea {
    resize: none;
    height: 300px;
  }
  #train-form, #test-form {
    display: none;
  }
  </style>
  <script src="js/convnet-min.js"></script>
</head>
<body>
  <div class="container">
    <div class="row">
      <div class="column" style="margin-top: 25px">
        <h2>Andjective-Noun composition learning to detect metaphoricity</h2>
        <p>Using this tool, one can train an adjective-noun composition function
          which can then be used to predict its metaphoricity.</p>
        <p>First, one needs to provide a list of positive  and negative examples
          on each line. Then  the model needs to be trained. When this process
          is finished,  one can test it using different adjective-noun phrases.</p>
        <p>In this demo, we are using <a href="https://drive.google.com/file/d/0B7XkCwpI5KDYNlNUTTlSS21pQmM/">these pretrained word embeddings</a>
          and our vocabulary is limited to <a href="http://bit.ly/1TQ5czN">words from this list</a>.
          The list has only  these adjectives:</p>
        <p>heated, clean, strong, dense, clear, warm, soft, sour, brilliant,
          murky, solid, weak, icy, rough, bitter, smooth, cold, heavy, shallow,
          bright, deep, dim, sweet</p>
        <form id="data-form">
          <div class="row">
            <div class="six columns">
              <label for="positive-samples">Positive Samples</label>
              <textarea class="u-full-width" placeholder="e.g. deep person" id="positive-samples"></textarea>
            </div>
            <div class="six columns">
              <label for="negative-samples">Negative Samples</label>
              <textarea class="u-full-width" placeholder="e.g. deep sea" id="negative-samples"></textarea>
            </div>
          </div>
          <input type="submit" value="Load Embeddings"/>
        </form>
        <div id="data-progress-bar"><div></div></div>
        <form id="train-form">
          <label for="train-epoch">Epochs</label>
          <input type="text" id="train-epoch" value="20"/>
          <input type="submit" value="Train"/>
        </form>
        <hr/>
        <div id="status-progress-bar"><div></div></div>
        <form id="test-form">
          <label for="test-sample">Test sample</label>
          <input type="text" placeholder="deep conversation" id="test-sample" />
          <input type="submit" value="Test" />
        </form>
        <div id="results"></div>
      </div>
    </div>
  </div>

<script>

// The NN model:
var layer_defs = [
  {type:'input', out_sx:1, out_sy:1, out_depth:600},
  {type:'fc', num_neurons:300, activation: 'relu'},
  //{type:'fc', num_neurons:1, activation: 'sigmoid'},
  //{type:'regression', num_neurons:1},
  {type:'softmax', num_classes:2},
];

// create a net
var net = new convnetjs.Net();
net.makeLayers(layer_defs);
//net.layers.splice(5, 1);

var trainer = new convnetjs.Trainer(net,{
  method: 'adagrad',
  batch_size: 30
});

console.log(net);

var data = [];
var labels = [];
var data_str = [];

// test
/**
for (var i=0; i<1000; i++){
  var d = []
  var l = 0;
  if (Math.random()>0.5) {
    l = 1;
  }
  for (var j=0; j<600; j++){
    if ((j%2) * l > 0) {
      d.push(0.2+Math.random());
    } else {
      d.push(Math.random());
    }
  }
  //console.log(l, d);
  var x = new convnetjs.Vol(1,1,600,0.0);
  x.w = new Float64Array(d);
  data.push(x);
  labels.push(l);
}
**/
</script>

<script>

var textAreas = document.getElementsByTagName('textarea');
for(var i=0; i<textAreas.length; i++) {
  textAreas[i].innerHTML = textAreas[i].innerHTML.trim().split('\n').map(function(str){return str.trim()}).join('\n');
}

// shuffle function for javascript arrays:
// source: https://github.com/Daplie/knuth-shuffle
// https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
function shuffle(array) {
  var currentIndex = array.length, temporaryValue, randomIndex;

  // While there remain elements to shuffle...
  while (0 !== currentIndex) {

    // Pick a remaining element...
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex -= 1;

    // And swap it with the current element.
    temporaryValue = array[currentIndex];
    array[currentIndex] = array[randomIndex];
    array[randomIndex] = temporaryValue;
  }

  return array;
}

// ajax function which loads json fromat of word-vectors form data folder:
var getData = function (word, onready) {
  var rawFile = new XMLHttpRequest();
  rawFile.overrideMimeType("application/json");
  rawFile.open("GET", 'data/'+word+'.json', true);
  rawFile.onreadystatechange = function() {
      if (rawFile.readyState === 4 && rawFile.status == "200") {
          onready(word, JSON.parse(rawFile.responseText));
      }
  }
  rawFile.send(null);
}

var updateProgressbar = function(element, total, progress, text) {
  if (total >= 0 && progress >= 0) {
    element.style.display = "block";
    element.style.height = "30px";
    element.childNodes[0].style.height = "30px";
    element.childNodes[0].style.background = "#eeeeee";
    element.childNodes[0].style.width = 100*progress/total + "%";
    if (typeof(text) == 'undefined') {
      element.childNodes[0].innerHTML = 100*progress/total + "% (" + progress + "/" + total + ")";
    } else {
      element.childNodes[0].innerHTML = text;
    }
  }
}

document.getElementById("data-form").onsubmit = function(e) {
  data = [];
  labels = [];
  data_str = [];
  var this_form;
  if (typeof(e)=='undefined') {
    this_form = document.getElementById("data-form");
  } else {
    this_form = e.srcElement;
  }
  var neg_samples = this_form.elements['negative-samples'].value.trim().split('\n');
  var pos_samples = this_form.elements['positive-samples'].value.trim().split('\n');
  var embeddings = {};

  var phrases = neg_samples.concat(pos_samples);

  var vocabulary = [];
  for(var i=0;i<phrases.length;i++) {
    vocabulary = vocabulary.concat(phrases[i].trim().split(' '));
  };

  function onlyUnique(value, index, self) {
      return self.indexOf(value) === index;
  }

  vocabulary = vocabulary.filter( onlyUnique );


  var embeddings_ready = 0;
  var embeddings_onready = function(){
    for(var i=0;i<neg_samples.length;i++) {
      phrase = neg_samples[i].trim().split(' ');
      var x = new convnetjs.Vol(1,1,600,0.0);
      // concatenate two vectors:
      x.w = new Float64Array(embeddings[phrase[0]].concat(embeddings[phrase[1]]));

      data.push(x);
      labels.push(0);
      data_str.push(phrase);
    }
    for(var i=0;i<pos_samples.length;i++) {
      phrase = pos_samples[i].trim().split(' ');
      var x = new convnetjs.Vol(1,1,600,0.0);
      // concatenate two vectors:
      x.w = new Float64Array(embeddings[phrase[0]].concat(embeddings[phrase[1]]));

      data.push(x);
      labels.push(1);
      data_str.push(phrase);
    }
    document.getElementById("train-form").style.display = "block";
  }

  var onready = function(word, vector) {
    embeddings[word] = vector;
    embeddings_ready++;
    updateProgressbar(document.getElementById("data-progress-bar"), vocabulary.length, embeddings_ready)
    if (vocabulary.length == embeddings_ready) {
      embeddings_onready();
    }
  };

  for(var i=0;i<vocabulary.length;i++) {
    var word = vocabulary[i];
    getData(word, onready);
  };

  return false;
};

document.getElementById("train-form").onsubmit = function(e) {
  var epochs = e.srcElement.elements['train-epoch'].value;
  var status;
  if (data.length == 0) {
    document.getElementById("data-form").onsubmit();
  }
  updateProgressbar(
    document.getElementById("status-progress-bar"),
    epochs,
    1,
    "epoch="+1+", loss=0.0"
  );

  for(var iter=0;iter<epochs;iter++) {
    sumloss = 0;
    // shuffle the data!
    indeces= Array.apply(null, Array(data.length)).map(function (_, i) {return i;});
    shuffle(indeces);
    data = data.map(function(_,i){return data[indeces[i]]});
    labels = labels.map(function(_,i){return labels[indeces[i]]});
    data_str = data_str.map(function(_,i){return data_str[indeces[i]]});

    for(var i=0;i<data.length;i++) {
      //console.log(data[i], labels[i]);
      status = trainer.train(data[i], labels[i]);
      sumloss += status.cost_loss;
      //console.log(i, status);
    };
    console.log(sumloss/data.length);

    updateProgressbar(
      document.getElementById("status-progress-bar"),
      epochs,
      iter+1,
      "epoch="+(iter+1)+", loss="+sumloss/data.length
    );

  }
  document.getElementById("test-form").style.display = "block";
  return false;
};

document.getElementById("test-form").onsubmit = function(e){

  var phrase = e.srcElement.elements['test-sample'].value.trim().split(' ');
  var embeddings = {};
  var embeddings_ready = 0;
  var embeddings_onready = function(){
    console.log(embeddings);
    // concatenate two vectors:
    var x = new convnetjs.Vol(1,1,600,0.0);
    x.w = new Float64Array(embeddings[phrase[0]].concat(embeddings[phrase[1]]));
    score = net.forward(x);
    document.getElementById("results").innerHTML = "<h5>Score: " + Math.round(score.w[0]*10000)/100 + "%<h5>";
  }

  var onready = function(word, vector) {
    embeddings[word] = vector;
    embeddings_ready++;
    if (2 == embeddings_ready) {
      embeddings_onready();
    }
  };

  getData(phrase[0], onready);
  getData(phrase[1], onready);

  return false;
}
</script>
</body>
</html>
